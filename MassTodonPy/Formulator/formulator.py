# -*- coding: utf-8 -*-
#
#   Copyright (C) 2016 Mateusz Krzysztof Łącki and Michał Startek.
#
#   This file is part of MassTodon.
#
#   MassTodon is free software: you can redistribute it and/or modify
#   it under the terms of the GNU AFFERO GENERAL PUBLIC LICENSE
#   Version 3.
#
#   MassTodon is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
#   You should have received a copy of the GNU AFFERO GENERAL PUBLIC LICENSE
#   Version 3 along with MassTodon.  If not, see
#   <https://www.gnu.org/licenses/agpl-3.0.en.html>.

import re
from linearCounter.linearCounter import linearCounter as lCnt
from collections import defaultdict


class NegativeAtomCount(Exception):
    pass


def atomCnt2string(atomCnt):
    """Translate a dictionary of atom counts into a uniquely defined string.

    Parameters
    ----------
    atomCnt : Counter
        The chemical formula counter.

    Returns
    -------
    out : str
        A chemical formula string.
    """
    keys = atomCnt.keys()
    return "".join(el+str(atomCnt[el]) for el in sorted(keys))


def standardize_modifications(modifications):
    """Standardize modifications so that they meet
    the internal nomenclature scheme.

    Parameters
    ----------
    atomCnt : Counter
        The chemical formula counter.

    Returns
    -------
    out : defaultdict
        The atomic modifications.

    Notes
    -----
    It was easier for me to think of an amino acid as if it was composed
    out of three bricks: the left one, the center one, and the right one.
    The left one corresponds to the group with nitrogen,
    the center one - to the alpha carbon (including the side chain),
    and the right one - to the other carbon atom.
    """
    backboneAtom2aaNomen = {'N': 'L', 'Calpha': 'C', 'C': 'R'}
    R = defaultdict(lambda: defaultdict(lCnt))
    for tag, atomCnt in modifications.items():
        match = re.match(r"([a-z]+)([0-9]+)", tag, re.I)
        if match:
            aa, aa_idx = match.groups()
            aa_idx = int(aa_idx) - 1
        R[aa_idx][backboneAtom2aaNomen[aa]] = lCnt(atomCnt)
    return R


def prolineBlockedFragments(fasta):
    """Checks for c-z fragments that cannot occur because of proline.

    Parameters
    ----------
    fasta : str
        The fasta of the studied molecular species.

    Returns
    -------
    blocked : set
        A set of fragment names that cannot occur.
        Always contains the 'c0', which is too small to observe.
    """
    blocked = set('c0')
    for i, f in enumerate(fasta):
        if f == 'P':
            blocked.add('c' + str(i))
            blocked.add('z' + str(len(fasta)-i))
    return blocked


class Formulator(object):
    """A class for obtaining chemical formulas
    generated by a given type of a molecules.

    Parameters
    ----------
    fasta : str
        The fasta of the studied molecular species.

    Q : int
        The charge of the precursor ion.

    bricks : a dictionary of dictionaries of linearCounters
        The atomic counts of different amino acids,
        divided into different parts (left, center, right),
        that correspond to backbone C, C_alpha, and N atoms
        and atoms that neighbour them.

    distance_charges : int
        The minimal distance between charges on the protein.
        If set to 5, at least 4 amino acids must lay between
        consecutive *charged* amino acids.

    modifications : list
        A dictionary of modifications.

        The key in the modifications' dictionary should with of form
        **<N|Calpha|C><amino acid No>**, e.g. C10.

        The values contain dictionaries with diffs in elements,
        e.g. **{'H': 1, 'N': 1, 'O': -1}**."""

    def __init__(self, fasta, Q, bricks,
                 distance_charges=5,
                 modifications=lCnt()):
        self.Q = Q
        self.fasta = fasta
        self.d_charges = distance_charges
        self.modifications = standardize_modifications(modifications)
        self.bricks = bricks

    def getBrick(self, aaPart, aa, aaNo):
        brick = self.bricks[aa][aaPart] + self.modifications[aaNo][aaPart]
        if any(brick[elem] < 0 for elem in brick):
            raise NegativeAtomCount("Attention: your modification had an unexpected effect.\
            Part of your molecule now has negative atom count.\
            Bear that in mind while publishing your results.")
        return brick

    def protonate(self, frag):
        a, b, c = {'p': (1, 0, 1),
                   'c': (0, -1, 0),
                   'z': (0, 0, 1)}[frag]

        for q in range(1, self.Q+a):
            for g in range(b, self.Q-q+c):
                yield (q, g)

    def make_superatoms(self):
        self.superAtoms = []
        sA = lCnt()
        for aaNo, aa in enumerate(self.fasta):
            sA += self.getBrick('L', aa, aaNo)
            self.superAtoms.append(sA)
            sA = self.getBrick('C', aa, aaNo) + self.getBrick('R', aa, aaNo)
        sA += lCnt({'O': 1, 'H': 1})
        self.superAtoms.append(sA)
        self.superAtoms[0] += lCnt({'H': 1})

    def make_unprotonated_formulas(self):
        N = len(self.superAtoms)
        N_fasta = len(self.fasta)

        # precursor molecule
        precursor = ('precursor',
                     atomCnt2string(sum(self.superAtoms)),
                     N_fasta)
        self.unprotonated_formulas = [precursor]

        # exclude proline fragmented daughter ions
        blockedFragments = prolineBlockedFragments(self.fasta)

        # c fragments
        # Adding one extra hydrogen to meet the definition of a c fragment.
        cFrag = lCnt({'H': 1})
        for i in range(N-1):
            cFrag += self.superAtoms[i]
            cFrag_tmp = lCnt(cFrag)
            frag_type = 'c'+str(i)
            if frag_type not in blockedFragments and not i == 0:
                c_fragment = (frag_type, atomCnt2string(cFrag_tmp), i)
                self.unprotonated_formulas.append(c_fragment)

        # z fragments
        zFrag = lCnt()
        for i in range(1, N):
            zFrag += self.superAtoms[N-i]
            zFrag_tmp = lCnt(zFrag)
            frag_type = 'z'+str(i)
            if frag_type not in blockedFragments:
                z_fragment = (frag_type, atomCnt2string(zFrag_tmp), i)
                self.unprotonated_formulas.append(z_fragment)

    def make_formulas(self):
        # outcome variable
        self.formulas = []

        for molType, atomCnt_str, sideChainsNo in self.unprotonated_formulas:
            for q, g in self.protonate(molType[0]):
                potentialChargesNo = sideChainsNo // self.d_charges
                if sideChainsNo % self.d_charges > 0:
                    potentialChargesNo += 1
                    # +0000 +0000 00+  at most 3 charges
                if potentialChargesNo >= q:
                    self.formulas.append((molType,
                                          atomCnt_str,
                                          sideChainsNo,
                                          q,
                                          g))

    def get_formulas(self):
        self.superAtoms = self.make_superatoms()
        self.unprotonated_formulas = self.make_unprotonated_formulas()
        self.formulas = self.make_formulas()
        return self.formulas


def get_formulas(fasta, Q, bricks, distance_charges=5, modifications={}):
    """Generate fragments from the Roepstorff Scheme.
    Parameters
    ----------
    fasta : str
        The fasta of the studied molecular species.

    Q : int
        The charge of the precursor ion.

    bricks : a dictionary of dictionaries of linearCounters
        The atomic counts of different amino acids,
        divided into different parts (left, center, right),
        that correspond to backbone C, C_alpha, and N atoms
        and atoms that neighbour them.

    distance_charges : int
        The minimal distance between charges on the protein.
        If set to 5, at least 4 amino acids must lay between
        consecutive *charged* amino acids.

    modifications : list
        A dictionary of modifications.

        The key in the modifications' dictionary should with of form
        **<N|Calpha|C><amino acid No>**, e.g. C10.

        The values contain dictionaries with diffs in elements,
        e.g. **{'H': 1, 'N': 1, 'O': -1}**.

    Returns
    -------
    out : class
        The formulator class... Who the hell encoded that?

    Warning
    -------
        At present only the 'cz' fragmentation is supported.
    """

    F = Formulator(fasta=fasta,
                   Q=Q,
                   bricks=bricks,
                   distance_charges=distance_charges,
                   modifications=modifications)

    formulas = F.get_formulas()

    return formulas
